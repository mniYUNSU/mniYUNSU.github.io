---
layout: post
title: 'HTTPS의 개념'
date: 2022-02-04 09:29:20 +0700
categories: [Network]
tags: [HTTP, CS]
description: HTTPS는 HTTP 요청을 SSL(Secure Sockets Layer) 혹은 TLS(Transport Layer Security) 라는 알고리즘을 이용해 HTTP 통신을 하는 과정에서 내용을 암호화하여 데이터를 전송하는 방법이다.
---

# HTTPS

**HTTPS**는 **H**yper **T**ext **T**ransfer **P**rotocol **S**ecure Socket layer 의 약자이다.

HTTPS는 HTTP 요청을 **SSL(Secure Sockets Layer)**<sup id="user">[[1]](#user-ref)</sup> 혹은 **TLS(Transport Layer Security)**<sup id="user">[[2]](#user-ref)</sup> 라는 알고리즘을 이용해 HTTP 통신을 하는 과정에서 내용을 암호화하여 데이터를 전송하는 방법이다.

인증에서 **HTTPS 프로토콜을 사용해야만 하는 이유**는 HTTP보다 상대적으로 **안전한 방법**이고, 데이터 제공자의 **신원을 보장**받을 수 있기 때문이다. **데이터 제공자의 신원을 확인하고 보장**받는 게 인증에서 중요한 이유는 다음과 같다.

- 클라이언트는 데이터 제공자가 제공해준 데이터를 사용할 수밖에 없다.
- 클라이언트는 서버에 데이터 요청을 하고 이후 받은 데이터를 이용해서 화면을 렌더링하는 등의 작업을 해야 한다.
- 위 과정에서 요청 및 응답을 중간에서 가로채는 **중간자 공격**에 취약하다. **중간자 공격**은 클라이언트와 서버 사이에서 공격자가 서로의 요청, 응답의 데이터를 탈취 및 변조하여 다시 전송하는 공격이다.

## 암호화

HTTPS 프로토콜의 특징 중 하나는 **암호화된 데이터**를 주고받기 때문에, 중간에 인터넷 요청이 탈취되더라도 그 내용을 알아볼 수 없다. 데이터를 암호화하여 전송하는 HTTPS 프로토콜을 사용한다면 비밀번호와 같은 중요한 데이터가 유출될 가능성이 HTTP 프로토콜보다 현저히 적어지게 된다.

**암호화**는 일련의 정보를 임의의 방식을 사용하여 다른 형태로 변환하여 해당 방식에 대한 정보를 소유한 사람을 제외하고 이해할 수 없도록 `알고리즘`을 이용해 정보를 관리하는 과정이다.

단순한 알고리즘의 예로 문자열을 3씩 더한 문자열로 저장하고, 응답할땐 문자열을 -3씩 더한 문자열로 응답하는 간단한 알고리즘이 있을 수 있다. 서버는 이 알고리즘을 갖고있고, 클라이언트로부터 요청이 오고, 그 알고리즘을 토대로 DB에 사용자 정보를 저장한다. 이후 응답할 때, DB에서 정보를 가져올 때, 서버는 복호화를 통해 인증 정보를 파악 후 클라이언트로 응답을 보낸다.

### Hashing

해싱은 어떠한 문자열에 **임의의 연산**을 적용하여 다른 문자열로 변환하는 것이다.

해싱의 특징은 세 가지가 있다.

1. 모든 값에 대해 해시 값을 계산하는데 오래 걸리지 않아야 한다. <br> 해싱 과정이 오래 걸리게 되면, 유저들은 불편함을 느낄 수 밖에 없다.
2. 최대한 해시 값을 피해야하며 모든 값은 고유한 해시 값을 가져야 한다. <br> 극히 낮은 확률로 다른 문자열이 같은 해시 값을 갖는 경우가 있다. 이를 방지하기 위한 알고리즘은 대부분 구현되어 있다.
3. 아주 작은 단위의 변경이라도 완전히 다른 해시 값을 가져야 한다. <br> 암호가 마지막 자리를 빼고 전부 같더라도, 아예 다른 해시 값을 가져야 한다.

대표적인 알고리즘으론 **SHA1**, **SHA256** 등이 있다.

### Salt

암호화해야 하는 값에 어떤 **별도의 값**을 추가하여 결과를 변형하는 것이다.

**Salt**의 흐름은 다음과 같다.

1. 암호화만 한다면 해시된 결과가 늘 동일하다. 그래서 해시된 값과 원래 값을 테이블로 만들어서 **decoding**하는 경우가 생긴다.
2. 이를 방지하기 위해, 원본 값에 임의로 약속된 **별도의 문자열**을 추가하여 해싱을 진행한다. 만약, 알고리즘이 노출되더라도 기존 해시값과 전혀 다른 해시값이 반환되기 때문에 원본 값을 보호할 수 있다.
3. 기존 값 - (암호화할 값) => (해싱된 값) <br>
   Salt - (암호화할 값) + **(Salt 값)** => (해싱된 값)

<br>

**Salt**를 사용할 때 주의할 점은 다음과 같다.

- Salt는 유저와 패스워드 별로 **유일한** 값을 가져야 한다.
- 사용자 계정을 생성할 때와 비밀번호를 변경할 때 마다 **새로운 임의의 Salt**를 사용해서 해싱해야 한다.
- Salt는 절대 **재사용**해선 안된다.
- Salt는 **DB의 유저 테이블에 같이 저장되어야** 한다.

## 인증서

브라우저는 인증서에서 해당 인증서를 발급한 CA 정보를 확인하고 인증된 CA가 발급한 인증서가 아니라면 경고창을 띄워 서버와 연결이 안전하지 않다는 화면을 보여준다. 브라우저는 인증서의 도메인 정보와 데이터 제공자의 도메인 정보가 다른 **중간자 공격**을 감지하여 보안 위협으로부터 사용자 및 사용자의 데이터를 보호할 수 있다.

그리고 브라우저들은 인증된 CA가 발급한 인증서를 이용하여 데이터를 제공하는 안전한 서버를 사용할 수 있게 사용자를 유도한다.

### Cookie

**쿠키**는 서버에서 클라이언트에 데이터를 저장하는 방법의 하나이다.

**HTTP는 Stateless(무상태성)인데, 우리의 정보가 유지되는 이유는 쿠키가 있기 때문**이다. 어떤 웹사이트에 들어갔을 때 서버가 일방적으로 클라이언트에 전달하는 작은 데이터라고 볼 수 있다. 해당 도메인에 쿠키가 존재하면, 웹 브라우저는 도메인에게 HTTP 요청 시 쿠키를 함께 전달한다.

쿠키는 사용자 선호, 테마 등 장시간 보존해야 하는 정보 저장에 적합하다. 예시로, 로그인 상태 유지(자동 로그인), 다크 모드, 쇼핑몰의 장바구니 등이 있다.

서버가 원한다면 서버는 클라이언트에서 쿠키를 이용하여 데이터를 가져올 수 있다. 그러므로 쿠키를 이용하는 것은 단순히 서버에서 클라이언트에 쿠키를 전송하는 것만 의미하지 않고 **클라이언트에서 서버로 쿠키를 전송하는 것도 포함**된다.

<figure>
<img src="./../../images/common-https.jpeg" alt="common-https">
<figcaption>Fig 1. 메이플스토리 캐릭터</figcaption>
</figure>

어릴 때 피시방에서 게임을 하다가 선불 시간이 다 되어 컴퓨터가 강제로 로그아웃 되는 경험은 한 번쯤 해본 경험이다. 그렇게 로그아웃 되고 다음날 게임에 접속해보면 **해킹당해서 캐릭터가 벌거벗고 있는 모습**을 심심찮게 볼 수 있었다.

이 로그인 정보들은 **쿠키**인데, 이 쿠키가 일정 시간 후에 사라졌다면 위와 같은 사고는 발생하지 않았을 것이다. 쿠키의 다양한 옵션 중에서 **MaxAge or Expires** 는 쿠키의 **유효 기간을 설정하여, 일정 시간 후 자동으로 소멸**되게 할 수 있다.

또한, 쿠키는 `<script>` 태그로 접근이 가능하다. 그렇기 때문에 XSS 공격에 취약하다. `<script>`태그로 접근을 불가능하도록 **HttpOnly** 옵션을 사용할 수 있다.

그리고 **CSRF 공격** 등을 막기 위해 **SameSite** 옵션을 사용할 수 있다.

이는 각 옵션에 따라 서버의 쿠키 전송 여부를 결정할 수 있다.

- `Lax` : GET 요청만 쿠키 전송 가능
- `Strict` : 쿠키 전송 불가
- `None` : 모든 요청에 대해 쿠키 전송 가능

위 옵션 중 **sameSite='none'** 은 HTTPS 프로토콜과 Secure 쿠키 옵션이 반드시 필요하다.

기타 다양한 옵션들은 아래와 같다.

**1. Domain**

쿠키 옵션에서 도메인은 포트 및 서브 도메인 정보, 세부 경로를 포함하지 않는다. 여기서 서브 도메인이란 `www` 같은 도메인 앞에 추가로 작성되는 부분이다.

따라서 요청해야 할 URL이 `http://www.localhost.com:3000/users/login` 이라 하면 Domain은 `localhost.com`이 된다.

**2. Path**

세부 경로는 서버가 라우팅할 때 사용하는 경로이다. 만약 요청해야 하는 URL이 `http://www.localhost.com:3000/users/login` 인 경우라면 여기에서 Path는 `/users/login`이 된다.

명시하지 않으면 기본으로 `/` 으로 설정되어 있다.

Path 옵션의 특징은 설정된 Path를 전부 만족하는 경우 요청하는 Path가 추가로 더 존재하더라도 쿠키를 서버에 전송할 수 있다. 즉 Path가 `/users`로 설정되어 있고, 요청하는 세부 경로가 `/users/login` 인 경우라면 쿠키 전송이 가능하다.

하지만 `/user/login`으로 전송되는 요청은 Path 옵션을 만족하지 못하기 때문에 서버로 쿠키를 전송할 수 없다.

**3. Secure**

쿠키를 전송해야 할 때 사용하는 프로토콜에 따른 쿠키 전송 여부를 결정한다. 만약 해당 옵션이 `true`로 설정된 경우, **HTTPS 프로토콜**을 이용하여 통신하는 경우에만 쿠키를 전송할 수 있다.

**4. HttpOnly**

기본으로 `false`로 지정되어 있다. 만약 이 옵션이 `false`인 경우 자바스크립트에서 쿠키에 접근이 가능하므로 **XSS** 공격에 취약하다.

서버는 클라이언트에 인증 정보를 담은 쿠키를 전송하고, 클라이언트는 전달받은 쿠키를 요청과 같이 전송하여 Stateless 한 인터넷 연결을 Stateful 하게 유지할 수 있다. 하지만 기본적으로는 쿠키는 오랜 시간 동안 유지될 수 있고, 자바스크립트를 이용해서 쿠키에 접근할 수 있기 때문에 **쿠키에 민감한 정보를 담는 것은 위험**하다.

### Session

사용자가 인증에 성공한 상태를 **세션**이라고 부른다.

세션은 접속 상태를 서버가 가진다. 즉, 신뢰할 수 있는 유저인지 서버에서 추가적으로 확인이 가능하다.

클라이언트마다 고유한 ID를 쿠키에 담아 클라이언트에 전송한다. 클라이언트의 중요한 데이터는 서버에서 관리하게 되는 것이다. 서버는 클라이언트로부터 받은 ID를 서버에 저장된 ID와 비교하여 유저의 신뢰성을 판단한다.

쿠키는 클라이언트에 정보를 저장하여, 서버의 입장에선 어떤 사용자가 이 정보를 갖고 서버에 요청을 하더라도 같은 응답을 할 뿐이다. 즉, 상대적으로 세션은 보안성이 쿠키보다 뛰어나다. 그러나, 하나의 서버에서만 접속 상태를 가지기 때문에, 분산에 불리하다.

## 적용 예시

```js
const express = require('express')
const cors = require('cors')
const session = require('express-session')
const app = express()

app.use(
  session({
    secret: '@SECRET',
    resave: false,
    saveUninitialized: true,
    cookie: {
      domain: 'localhost',
      path: '/',
      maxAge: 24 * 6 * 60 * 10000,
      sameSite: 'none',
      httpOnly: true,
      secure: true,
    },
  })
)

app.use(express.json())
// CORS 설정
app.use(
  cors({
    origin: true,
    credentials: true,
    // credentials 설정을 주는 것으로 서버와 클라이언트 간 포트가 달라도 쿠키를 주고받을 수 있다.
    methods: ['GET', 'POST', 'OPTIONS'],
  })
)
```

---

### Notes

<small id="user-ref"><sup>[[1]](#user)</sup>**SSL(보안 소켓 계층(Secure Sockets Layer, SSL))** : SSL은 웹사이트와 브라우저(혹은, 두 서버) 사이에 전송된 데이터를 암호화하여 인터넷 연결을 보안을 유지하는 표준 기술이다. 이는 해커가 개인 정보 및 금융 정보를 포함한 전송되는 모든 정보를 열람하거나 훔치는 것을 방지한다.</small>

<small id="user-ref"><sup>[[2]](#user)</sup>**TLS(전송 계층 보안(Transport Layer Security, TLS))** : TLS는 가장 최신 기술로 더 강력한 버전의 SSL이다. 그러나 SSL이 더 일반적으로 사용되는 용어이기에 여전히 보안 인증서는 SSL이라 불린다.</small>

### Reference

- <a href="https://www.digicert.com/kr/what-is-ssl-tls-https" target="_blank" rel="noopener">SSL과 TLS</a>
